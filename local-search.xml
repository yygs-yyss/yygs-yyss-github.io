<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>git使用总结</title>
    <link href="/2023/04/01/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2023/04/01/git%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="在工作中常用的操作"><a href="#在工作中常用的操作" class="headerlink" title="在工作中常用的操作"></a>在工作中常用的操作</h2><h3 id="1-初始化与拉取"><a href="#1-初始化与拉取" class="headerlink" title="1. 初始化与拉取"></a>1. 初始化与拉取</h3><ul><li>git init: 在某一文件夹下执行此命令，就会创建.git目录，git仓库也就创建好了</li><li>git clone 拉取远程仓库代码，默认同名拉取，如果需要重命名，可以使用git clone [url] [new_name]</li></ul><h3 id="2-基本的快照"><a href="#2-基本的快照" class="headerlink" title="2. 基本的快照"></a>2. 基本的快照</h3><ul><li>基本流程：<ol><li>git add：可以添加多个文件，文件路径后面叠加即可git add [file_path…]，不一定要git add . (此操作会递归的将当前文件夹下所有文件add一下)这样可能会把不需要的文件提交到远程仓库，file_path可以通过git status查看</li><li>git status查看当前状态，红色的是未add到缓存的，绿色是已经add但是未commit的</li><li>git diff</li></ol><ul><li>git diff没有其他参数直接使用此命令会显示所有未add 的更改（即红色部分的更改）</li><li>git diff –cached会显示已经add的尚未commit的更改（即绿色部分的更改）</li><li>git diff HEAD会显示所有改动（包括红色和绿色的更改）</li><li>git diff –stat简略显示哪些文件更改了，但不显示具体更改内容</li></ul><ol start="4"><li>git commit：add命令只会写入缓存，没有真正写入存储，commit会真正写入存储</li><li>首先要设置config，这些config就是每一条commit的基本信息，不要乱填<br>1. git config –global user.name ‘Your Name’<br>2. git config –global user.email you@email</li><li>git commit -m [“本次提交的简要信息”]</li></ol></li><li>其它常用方法：<ul><li>git reset<ul><li>git reset HEAD – [file_name]将当前已经add进缓存的file_name文件移出缓存</li><li>git reset [commit_no]可以回退到commit_no版本</li></ul></li><li>git rm</li></ul></li></ul><h3 id="3-分支与合并"><a href="#3-分支与合并" class="headerlink" title="3. 分支与合并"></a>3. 分支与合并</h3><ul><li>基本流程<ul><li>git branch<ul><li>git branch列出可用的分支，*号标记的分支就是当前分支</li><li>git branch [branch_name]创建叫branch_name的新分支</li></ul></li><li>git checkout<ul><li>git checkout [branch_name]切换到branch_name的分支</li><li>git checkout -b [branch_name]创建并切换到branch_name分支</li><li>git checkout -d [branch_name]删除分支</li></ul></li><li>git merge<ul><li>git merge [branch_name]将当前分支和branch_name分支合并</li></ul></li></ul></li></ul><h3 id="4-其他"><a href="#4-其他" class="headerlink" title="4. 其他"></a>4. 其他</h3><ul><li>git submodule</li></ul><h2 id="在工作中常用的场景"><a href="#在工作中常用的场景" class="headerlink" title="在工作中常用的场景"></a>在工作中常用的场景</h2><h3 id="取消当前修改的内容（还未add、commit）"><a href="#取消当前修改的内容（还未add、commit）" class="headerlink" title="取消当前修改的内容（还未add、commit）"></a>取消当前修改的内容（还未add、commit）</h3><ul><li>git checkout – file_name</li><li>git checkout .取消当前目录下所有修改内容</li></ul><h3 id="修改已经add的文件（还未commit）"><a href="#修改已经add的文件（还未commit）" class="headerlink" title="修改已经add的文件（还未commit）"></a>修改已经add的文件（还未commit）</h3><ul><li>git reset HEAD <file_name></li></ul><h3 id="修改已经commit的文件"><a href="#修改已经commit的文件" class="headerlink" title="修改已经commit的文件"></a>修改已经commit的文件</h3><ul><li>git reset <commit_number>回退版本</li></ul><h3 id="修改已经推到远程仓库的文件"><a href="#修改已经推到远程仓库的文件" class="headerlink" title="修改已经推到远程仓库的文件"></a>修改已经推到远程仓库的文件</h3><ul><li>git push -f修改后强制再推上去，-f 强制上推</li></ul><h3 id="提交MR之前需要rebase一下"><a href="#提交MR之前需要rebase一下" class="headerlink" title="提交MR之前需要rebase一下"></a>提交MR之前需要rebase一下</h3><ul><li>因为是多人合作编写代码，可能出现其它分支提前合入主分支，而你的分支没有加入这一部分代码</li><li>具体操作<ul><li>git pull origin clickhouse_service:clickhouse_service origin是所要拉取的git远程源clickhouse_service是主分支，此步骤就是将主分支更新为最新代码</li><li>git checkout &lt;当前要提交的分支名&gt;切回当前分支</li><li>git rebase clickhouse_servicereabse操作<ul><li>Rebase 操作，会分析两个分支共同祖先，然后从公共祖先一次往后将clickhouse_service每个提交节点与当前分支合并，直到合并到最后一个节点。<br><img src="/img/git-rebase.jpg" alt="git rebase"></li><li>每合并一个节点需要add、git rebase –continue</li></ul></li><li>执行命令之后，再提交MR操作，这样的好处是master分支上很清晰，不会有多余的commit提交记录（相比直接merge）<br>合并已经commit的节点</li></ul></li><li>git rebase -i HEAD~2将Head指向的最近的两个commit合并<ul><li>将不需要的commit前面的pick改为s或其它，具体可以看解释，pick代表保留当前，s代表合并到前一分支</li><li>将提交的信息修改统一</li><li>可能会产生冲突<ul><li>git status查看冲突，并进入冲突文件，解决冲突</li><li>git add &lt;文件名&gt; 添加解决冲突后的文件</li><li>git status确认已经无冲突</li><li>git rebase –continue</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术文章</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>工作</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/04/01/hello-world/"/>
    <url>/2023/04/01/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>生活随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MSCN论文总结</title>
    <link href="/2023/03/30/MSCN%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <url>/2023/03/30/MSCN%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="利用深度学习进行基数估计"><a href="#利用深度学习进行基数估计" class="headerlink" title="利用深度学习进行基数估计"></a>利用深度学习进行基数估计</h2><h3 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h3><ul><li>基于深度学习来作基数估计，设计了一种MSCN网络model</li><li>提升了0 Tuple问题的精确度（但没有完全解决0 Tuple 问题）</li><li>减少了连接join数量变多时的误差</li><li>使用真实世界IMDb数据集对方法进行了评估，结果表明该方法比基于采样的技术更稳健</li></ul><h3 id="需要解决的问题："><a href="#需要解决的问题：" class="headerlink" title="需要解决的问题："></a>需要解决的问题：</h3><ol><li>将查询作怎样的特征化</li><li>选择何种监督学习算法（设计了怎样的模型）</li><li>解决“冷启动问题”</li></ol><h4 id="将查询作怎样的特征化"><a href="#将查询作怎样的特征化" class="headerlink" title="将查询作怎样的特征化"></a>将查询作怎样的特征化</h4><p><img src="/img/query.png" alt="query"><br>我们设Q为查询的全集，$$v(a)表示对a进行one-hot编码，norm(a)表示对a进行标准化$$<br>$$ q \in Q, q&#x3D;(T_q, J_q, P_q)$$<br>$$ T_q&#x3D;(v(tid), v(samples)), samples可以代表表数量或bitmaps $$<br>$$J_q&#x3D;(v(join))$$<br>$$P_q&#x3D;(v(col), v(op), norm(val))$$</p><h4 id="模型MSCN"><a href="#模型MSCN" class="headerlink" title="模型MSCN"></a>模型MSCN</h4><p>对于每一个$$s \in S(S是query特征化后的集合)$$，使用MLP全连接多层神经网络学习，一次处理batch_size数量的查询，对模型输出的结果取平均值作为最终结果。<br>模型结果会输出一个标准化后的估计的基数，将其恢复为实际数据后与真实数据做比较（做除法）</p><h4 id="解决“冷启动问题”"><a href="#解决“冷启动问题”" class="headerlink" title="解决“冷启动问题”"></a>解决“冷启动问题”</h4><p>基于模式信息生成随机查询并从数据库中的实际值提取数据来获得初始训练数据集。</p><ol><li>随机选择一个数$$J_q(0 \le J_q \le 2)$$</li><li>随机选择一个至少关联一个其它表的表</li><li>对于$$|J_q|&gt;0$$, 选择一个新表，将join edge加入查询，重复$$J_q$$次</li><li>随机选择一个数$$P_q(0 \le P_q \le num non-key columns)$$, non-key columns非主键外键的列</li><li>生成$$P_q$$个predicate<br>Enriching the Training Data</li></ol><ul><li>Table特征化加入样本数据信息，比如samples的数量或bitmaps（table上对应的predicate）</li></ul><h3 id="评估"><a href="#评估" class="headerlink" title="评估"></a>评估</h3><p>使用了三种数据集</p><ol><li>synthetic workload：合成数据集，最多只有2个join</li><li>scale：0-4个join均有100个</li><li>JOB-light：Join order benchmark上的数据集<br><img src="/img/dataset.png" alt="dataset"></li></ol><h4 id="0-Tuple问题"><a href="#0-Tuple问题" class="headerlink" title="0-Tuple问题"></a>0-Tuple问题</h4><p><img src="/img/0-tuple.png" alt="0-tuple"></p><ul><li>0-tuple问题得到了优化，但是并没有彻底解决</li></ul><h4 id="有无samples数据对效果的影响"><a href="#有无samples数据对效果的影响" class="headerlink" title="有无samples数据对效果的影响"></a>有无samples数据对效果的影响</h4><p><img src="/img/sample.png" alt="sample"></p><h4 id="泛化能力的测试"><a href="#泛化能力的测试" class="headerlink" title="泛化能力的测试"></a>泛化能力的测试</h4><h4 id="存在的缺点："><a href="#存在的缺点：" class="headerlink" title="存在的缺点："></a>存在的缺点：</h4><ol><li>0-tuple问题不能完全解决</li><li>多表泛化能力不理想</li><li>不支持like等查询</li></ol>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>论文总结</tag>
      
      <tag>AI4DB</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
